(1 2 3)
(+ 2 3)
(* 4 5)
(- 10 3)
(/ 15 3)
(= 5 5)
(< 4 7)
(> 8 3)
(not true)
(and true false)
(or true false)
(list 1 2 3)
(cons 'a '(b c))
(car '(1 2 3))
(cdr '(1 2 3))
(length '(1 2 3))
(nth 2 '(1 2 3))
(eq 'a 'a)
(equal '(1 2 3) '(1 2 3))
(cond (true 'yes) (false 'no))
(quote (1 2 3))
(if true 'yes 'no)
(let ((x 5) (y 10)) (+ x y))
(setf a 42)
(defun square (x) (* x x))
((lambda (x) (* x x)) 7)
(apply '+ '(1 2 3 4 5))
(eval (list '+ 2 3))
(format "Hello, ~a!" 'world)
(read)
(write "Hello, Lisp!")
(gensym)
(load "my-program.lisp")
(progn (print 'one) (print 'two))
(time (fib 20))
(with-open-file (file "data.txt" :direction :input) (read-line file))
(with-output-to-string (output) (format output "Hello, ~a!" 'world))
(with-input-from-string (input "1 2 3 4") (read input))
(trace 'square)
(defun greet (name) (format "Hello, ~a!" name))
(greet 'Alice)
(and (eq 1 1) (eq 'a 'a))
(or (eq 1 2) (eq 'a 'b))
(listp '(1 2 3))
(atom 'symbol)
(numberp 42)
(symbolp 'symbol)
(stringp "text")
(null ())
(cons 'a 'b)
(reverse '(1 2 3))
(append '(1 2) '(3 4))
(member 'a '(b c a d))
(remove 'b '(b c a d))
(intersection '(1 2 3) '(3 4 5))
(union '(1 2 3) '(3 4 5))
(difference '(1 2 3) '(3 4 5))
(sort '(3 1 2))
(nthcdr 2 '(1 2 3 4 5))
(copy-list '(1 2 3))
(eq 1 1)
(equal '(1 2) '(1 2))
(eq 1 'a)
(equal "hello" "world")
(quote ())
(if false 'yes 'no)
(cond (false 'no) (true 'yes))
(let ((x 5) (y 10)) (+ x y))
(setf x 42)
(setf (car list) 'new-value)
(defun multiply (x y) (* x y))
((lambda (x y) (* x y)) 7 3)
(apply '+ 1 2 3 4 5)
(eval (list '+ 2 3))
(format "Hello, ~a!" 'world)
(read)
(write "Hello, Lisp!")
(gensym)
(load "my-program.lisp")
(progn (print 'one) (print 'two))
(time (fib 20))
(with-open-file (file "data.txt" :direction :input) (read-line file))
(with-output-to-string (output) (format output "Hello, ~a!" 'world))
(with-input-from-string (input "1 2 3 4") (read input))
(trace 'multiply)
(defun factorial (n) (if (= n 0)))
# not yet implemented
# (macroexpand '(defmacro double (x) (* 2 ,x)))`
# (defmacro double (x) (* 2 ,x))`
# (macroexpand '(defmacro double (x) (* 2 ,x)))`
# (defmacro double (x) (* 2 ,x))`
# (consp '(1 . 2))
